

```mermaid
graph BT

B[$$ \otimes $$]
C[$$ \otimes $$]
D[$$ \otimes $$]
E[$$  \bigoplus  $$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E

classDef default rx:40,ry:40;

```

## hourglasses

â‹ˆ â§– â§” â§“ â§–

```mermaid
graph LR

B[â‹ˆ]
C[â‹ˆ]
D[â‹ˆ]
E[$$\LARGE â§–$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E

classDef default rx:40,ry:40;

```

## nested intersection / union

	


```mermaid
graph LR

B[â‹’]
C[â‹’]
D[â‹’]
E[â‹“]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E

classDef default rx:40,ry:40;

```

## other nested



```mermaid
graph LR

B[â— ]
C[â— ]
D[â—¡]
E[$$\LARGEâ›­$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E

classDef default rx:40,ry:40;

```

## shields
â˜– â˜—

```mermaid
graph LR


B[â˜–]
C[â˜–]
D[â˜–]
E[$$\LARGE â˜—$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## h hourglass + 4pin star


```mermaid
graph LR


B[â‹ˆ]
C[â‹ˆ]
D[â‹ˆ]
E[$$\LARGE âœ§$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## 4 pin stars
âœ¦âœ§

```mermaid
graph LR


B[âœ¦]
C[âœ¦]
D[âœ¦]
E[$$\LARGE âœ§$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```

### Alchemy 1

```mermaid
graph LR


B[ğŸœ•]
C[ğŸœ•]
D[ğŸœ•]
E[$$\LARGE 	ğŸ¢	$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```

### Alchemy 2

```mermaid
graph LR


B[ğŸœ•]
C[ğŸœ•]
D[ğŸœ•]
E[$$\LARGE 	ğŸ£	$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


### Alchemy 3

```mermaid
graph LR


B[â‹ˆ]
C[â‹ˆ]
D[â›» â]
E[$$\LARGE 	$$   ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


### Runic 1

```mermaid
graph LR


B[ğŸœ•]
C[ğŸœ•]
D[ğŸœ•]
E[$$\LARGE á›Ÿ $$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```




### Runic 3

```mermaid
graph LR


B[â‹ˆ]
C[â‹ˆ]
D[â‹ˆ]
E[$$\LARGE ğŸ $$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```

## Alchemy 5

```mermaid
graph LR


B[â‹ˆ]
C[â‹ˆ]
D[â‹ˆ]
E[$$\LARGE 	ğŸœ•	$$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## Alchemy 5

ã‰¦ ã…‚

```mermaid
graph LR


B[ã‰¦]
C[ã‰¦]
D[ã‰¦]
E[$$\LARGE 	ã‰¥ ã‰¦ ã…‚ $$]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```



## Alchemy 5

â§‰ âœœ

```mermaid
graph LR


B[â… â§‰ ã…‚ â]
C[â§‰ â‹ˆ]
D[â]
E[$$\LARGE ã…‚ $$ ã…‚]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## Alchemy 6

â§‰ âœœ  â‹ˆ ã…‚ â… â—«

```mermaid
graph LR


B[â‹ˆ]
C[â‹ˆ]
D[â‹ˆ]
E[$$\LARGE ã…‚ $$ ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## Alchemy 7

â§‰ âœœ  â‹ˆ ã…‚ â… â—«

```mermaid
graph LR


B[â—«]
C[â—«]
D[â—«]
E[$$\LARGE ã…‚ $$ ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## Alchemy 8

â§‰ âœœ  â‹ˆ ã…‚ â… â—«

ğŸœ• â—« ã…‚

â© â©

```mermaid
graph LR


B[â©]
C[â©]
D[â©]
E[$$\LARGE â©  $$  ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## Alchemy 9

â§‰ âœœ â‹ˆ â‹ˆ â—« ğŸŠ ã…‚ â… â—«
ğŸŠ ê—¯ â‹ˆ â¨ â—«
ğŸœ• â—« ã…‚

â© â©

```mermaid
graph LR


B[â¨]
C[â¨]
D[â¨]
E[$$\LARGE â—«  $$  ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## Alchemy 10

â§‰ âœœ  â‹ˆ â—« ğŸŠ ã…‚ â… â—«
ğŸŠ
ğŸœ• â—« ã…‚

â© â©

```mermaid
graph LR


B[â‹ˆ]
C[â‹ˆ]
D[â‹ˆ]
E[$$\LARGE ã…‚  $$  ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


## Alchemy 11

a â—« b   
a ğŸœ• b



â§‰ âœœ â—² â‹ˆ â—« ğŸŠ ã…‚ â… â—« ê¯¡
ğŸŠ
ğŸœ• â—«  ã…‚

â© â©

â˜

### Alchemy 12

```mermaid
graph LR


B[ğŸœ•]
C[ğŸœ•]
D[ğŸœ•]
E[$$\LARGE â—«  $$  ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```

### Alchemy 13

ê›˜ ìœ¼ ë¯€ ì˜¤ ëª¨

```mermaid
graph LR


B[ì˜¤]
C[ì˜¤]
D[ì˜¤]
E[$$\LARGE ëª¨  $$  ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```

### Alchemy 14

â° â°Š â°:too emoji like, bad contrast

```mermaid
graph LR


B[â°]
C[â°]
D[â°]
E[$$\LARGE â°  $$  ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```


### Alchemy 15

â° â°Š â°£ æ—¥ à´¤ êš¸ â°:too emoji like, bad contrast
â© â¼ ãƒ° ğŸœ• â†€ ã‰¤ ã‰¦ â©© â â’ â‘  â©Œ â–¦ â–

```mermaid
graph LR


B[â]
C[â]
D[â]
E[$$\LARGE â’  $$  ]


A -- 4 --> B
A -- 2 --> C
A -- 3 --> D

B -- 3 --> E
C -- 3 --> E
D -- 3 --> E


classDef default rx:40,ry:40;

```



### Path-finding problems in graphs

p157 Gondran-Minoux gondran-minoux-graphs-dioids-and-semirings-new-models-and-algorithms

See Algorithm 4 p152: 

Algorithm 4 (Generalized Gaussâ€“Jordan): Computation of the matrices A+ and Aâˆ—

Let us consider here the case where B = I

Algorithm 4' Computation of A^+ and A^âˆ— in the case where G(A) does not contain a 0-absorbing circuit
```
(a) A^[0] = A
(b) For k = 1 . . . n
        For i = 1 . . . n
            For j = 1 . . . n
                a_ij^[k] â† a_ij^[kâˆ’1] âŠ• a_ik^[kâˆ’1] âŠ— a_kj^[kâˆ’1]  ;
            Endfor
        Endfor
    Endfor
(c) A^+ = A^[n] and A^âˆ— = I âŠ• A^[n]
```

**In the case of the shortest path problem in a graph without negative length circuits
(âŠ• = Min, âŠ— = +) algorithm 4' is none other than Floydâ€™s algorithm (1962).**

Algorithm 5 is the generalized â€œescalatorâ€ method, seems more complex.

G -> 
A -> 
E ->  
âŠ• -> MERGE?
âŠ— -> JOIN? 
Îµ -> ZERO
e -> ONE   

Identity matrix I -> I?



â„Ì… = The set R âˆª {+âˆ} âˆª {âˆ’âˆ}

| Problem types   | Problems solved  | E     | âŠ•   | âŠ—     | Îµ      |    e           |
| --------------- | ---------------- | ----- | ---- | ----- | ------ | -------------- |
| **Existence**   | Connectivity     | {0, 1}| Max  | Min   | 0      | 1              |   
| **Enumeration** | Generation of elementary paths  | ğ’«(X*) | Union | Latin multiplication | âˆ… | X |
|**Enumeration**|Multicriteria problems|ğ’«(â„Ì…^p)|Set of efficient paths of the union|Set of efficient paths of the sum|+âˆ^p|(0)^p|
| **Enumeration**|Generation of regular languages (Kleene)|Set of words|union|concatenation|âˆ…|the empty word|
| **Optimization** | Maximum capacity path | â„â‚Š âˆª {+âˆ} | Max | Min | 0 | +âˆ     | 
| **Optimization** | Minimum spanning tree, hierarchical classification | â„Ì… , â„â‚Š| Min| Max     | +âˆ     |-âˆ, 0|
|**Optimization**| Minimum cardinality path |      â„• âˆª {+âˆ}         |          Min          | + |  +âˆ     | 0  |
|**Optimization**|      Shortest path       |    â„â‚Š âˆª {+âˆ}           |          Min         | +  |  +âˆ     | 0  |  
|**Optimization**|       Longest path       |    â„â‚Š âˆª {+âˆ}           |           Max        | +  | -âˆ      | 0  | 
|**Optimization**| Maximum reliability path | {a | 0 â‰¤ a â‰¤ 1}        |           Max        | Ã—  | 0  | 1| 
|**Optimization**| Reliability of a network | Idempotent polynomials |Symmetrical difference| Ã—  | 0  | 1 |
| **Counting**   |        Path counting     |           â„•            |        +             | Ã—  | 0  | 1 |
| **Counting**   |       Markov chains      |  {a | 0 â‰¤ a â‰¤ 1}       |       +              | Ã—  | 0  | 1|
|**Opt & post-optimization** | k-th shortest path problem| Cone of â„Ì…â‚Š^k       | k smallest temrs of the 2 vector  |k smallest vectors of the sums of pairs    | (+âˆ)^k | (0,+âˆ,...,+âˆ) |  
|**Opt & post-optimization** | Î·-optimal paths| Ordered sequence of terms of â„ of amplitude Î· | Sequence formed by the k smallest sums of pairs of elements of the two sequences | (+âˆ)    | (0)    | 

---

Would you like me to format it as a **LaTeX table** or **CSV file** as well (for easier reuse in papers or code)?


**Character example**

ã„•â° = code point ã„•Â¹ = character ã„•Â² = token


```mermaid
block-beta
 columns 3
  
  block:sinistra      
      columns 1
      Domain
      A1(["A"])
      B1(["B"])
      
      F1(["F"])
      U1(["U"])
      N1(["N"])
      Y1(["Y"])
      
      Z1(["Z"])
      
  end

  
  %% Needed to fill in, feels hacky because of immature lib (v11.0)
  %% normal charts misalign badly
  block:colcentrale 
    columns 1
    A["  aaaaaaa "]
     
    style A fill:#0000,stroke:#0000,color:#0000;
    style colcentrale fill:#0000,stroke:#0000 
  end

  block:destra
      columns 1
      Codomain
      A2(["A"])
      B2(["B"])

      F2(["F"])
      U2(["U"])
      N2(["N"])
      Y2(["Y"])      
      
      Z2(["Z"])

  end

  F1-- "w978, 1" -->U2
  U1-- "w978, 2" -->N2
  N1-- "w978, 3" -->N2
  N1-- "w978, 4" -->Y2

  

```


**Character example**

```
 CAR     BALLADS

 C   B   L 
     A   D
 R       S
```


ã„•â° = code point ã„•Â¹ = character ã„•Â² = token

Each edge holds a word id and the sequence number. 

```mermaid
%%{init: { "flowchart": { "defaultRenderer": "elk" } }}%%
flowchart RL

  subgraph car
      direction TB
      C(["C"])
      R(["R"])    

      style car fill:#FD66, ;
  end


  subgraph common
      direction TB
      A(["A"])
      B(["B"])

      style common stroke-width:10,stroke:#2301, fill:#0000;
  end


  subgraph ballad
    L(["L"])
    D(["D"])
    S(["S"])

    style ballad stroke-width:20, stroke:#F001,fill:#0000;
  end

  B-- "w58, 1" -->A
  A-- "w58, 2" -->L
  L-- "w58, 3" -->L
  L-- "w58, 4" -->A
  A-- "w58, 5" -->D
  D-- "w58, 6" -->S

  C-- "w74, 1" -->A
  A-- "w74, 2" -->R


```

###  Mermaid horror

```mermaid
graph TD

    subgraph Vets
        L[ğŸ‘©â€âš•ï¸ Dr Lee]
        K[ğŸ‘¨â€âš•ï¸ Dr Kim]
        Z[Dr Z]
    end

    subgraph Owners
        subgraph Bianco family
            O1[ğŸ™‚ Alice]
            O2[ğŸ˜ Bob]
        end
        subgraph Verdi family        
            O3[ğŸ‘¨ Charlie]
            O4[ğŸ‘© Lisa]
            O5[ğŸ‘§ Emma]
        end
    end

    subgraph Dogs
        D1[ğŸ• Fido]
        D2[ğŸ© Bella]
        D3[ğŸ¦® Spot]
    end

    subgraph Peppo
      D1
      O1
    end


    C -- talks_to --> O1
    C -- sffd     --> C
    R -- talks_to --> O3

    O1 -- owns --> D1 & D2
    O2 -- owns --> D1 & D2
    O3 -- owns --> D3
    O4 -- owns --> D3
    O5 -- owns --> D3
    
```


### blokky

```mermaid
block
  columns 8
  
  block:sx:2
    columns 1
    
    C(["C"])
    space:2
    R(["R"])    

    style sx stroke-width:330, stroke:#FFD600;
  end

  space:1

  block:cr:2
    columns 1
    A2([" "])
    A(["A"])
    B(["B"])

    style cr stroke-width:1,stroke:#0000,fill:#0000;
    style A2 fill:#0000, stroke:#0000
  end

  space:1
  

  block:dx:2
    columns 3

    L(["L"]):1 space:2
    space:3
    
    space:2 L2([" "]):1
    D(["D"]):3
    space:3
    S(["S"]):3   
    space:3
    
    style L2 fill:#0000, stroke:#0000
    style dx stroke-width:330, stroke:#F001,fill:#0000;
  end
  

  B-- "w58, 1" -->A
  A-- "w58, 2" -->L
  L-- "w58, 3" -->L2
  L2-- " " -->L
  L-- "w58, 4" ---A2
  A2     --->     A
  A-- "w58, 5" -->D
  C-- "w74, 1" -->A
  A-- "w74, 2" -->R


  ```


## Relation pandas-style

```
R[property][i] = j
R[property,'w'][i] = weight of i ??   use multiindex ??

R['address']
R['address'][ì›ƒ_1] == ğŸ _3
R['address'] == Series[ğŸ _1,ğŸ _2, ğŸ _3 ....]
R['address'] == Series[ğŸ _1,ğŸ _2, ğŸ _3 ....]
```

## Term Rewriting Engine


### More in depth 

Rubi's magic is not Mathematica - it's the decision-tree rewrite system:

- every rule is a pure symbolic pattern
- conditions are pure symbolic predicates
- the rewriting engine itself is tiny
- tens of thousands of rules produce very deep reasoning

Rubiâ€™s design principles:

- Everything is a term
- All knowledge is rewrite rules
- Rules are extremely local
- Rule ordering matters
- Coverage is ensured by tree structure, not by semantics

Rubi is basically: Mathematics = structured rewrite database + tiny normalizer engine.

### Pictoji desiderata:

- character-level syntax
- full freedom in naming
- arbitrary user-defined theories
- symbolic rewriting
- proof-ability (if needed)
- scalable rulebases
- clear separation of kernel vs semantics
- compatibility with natural-language inference

Pictoji SHOULD be divided in:

- a tiny formal kernel (Metamath-like)
- a big rewrite rulebook (Rubi-like)
- a typed relational model (Pictoji meaning algebra)


### The Foundations

- prefer class name vs "sort" (too academic)
- heading is the theory name, refer to it as lowercase hyphened `the-foundations` like as in  [markdown links](the-foundations).
- Defs with 4 spaces or three backticks blocks



    class Rel[D,C,V]:           # Python style
        domain:   Set[D]
        codomain: Set[C]
        cells:    Dict[(C,D),V] 

    class Owns[D,C,Bool] (Rel[D,C,Bool]):
        pass

    class DogOwners(Owns):
        pass

    JoinOp:      Rel â¨ Rel -> Rel    # â¨ inside to directly signal infix? 

    1 : Final[Rel]      # Python-inspired const

    ì›ƒ : Rel            # unicode, var


Named rules as (typed) functions with 4 spaces:

    join_id_exp:  (e â¨ 1) <- e      # unbounded - DOES *NOT* look at the context

    join_id_exp(e):  (e â¨ 1) <- e      # bounded

    join_id_simp(e : Rel) -> Rel:  (e â¨ 1) -> e   # bounded, with typing      

More structured rule with guards, no exceptions but `Err` (rule ignored)

    join_id_dog_exp(e : Rel) -> Rel:  
        e IF e is Dog  ->  e â¨ 1_Dog   
                  _  ->  Err


Axioms as functions, MUST really produce truths (TODO more specific type?). 
Always start with `ax_`

    ax_join_id_r_all(e:Rel) -> Expr:  (e â¨ 1) == e    

Theorems as functions, MUST produce truths derived from axioms (TODO more specific type?). 
Always start with `thm_`

    thm_join_id(e:Rel) -> Expr:  (e â¨ 1) == e 

Non-ax, non-thm equality is basically a conjecture/test, may or may not be true`. 
Always begins with `test_`

    test_ow2_dup:   ì›ƒ ì›ƒ == ì›ƒÂ²


### The Foundations 2

We need to fix the notation

à®ƒ = set       nl
à®ƒ^ = Set      nl

System types:
    T = t^
    à®ƒ[t]^^ = SET[T]    (t is implicitly capitalized)
    à®ƒ[T]^^ = SET[T]    
    à®ƒ[T]^^1 = SET[T]   
    à®ƒ[T]^^n = SET[T] X SET[T] X .... X SET[T]    n times  
    ğŸš[T]^^ = LIST[T] 
    ...

if T is a System type then the resulting expression is considered a System type. 



à®ƒ[T]^^ == SET[T]            # System type, T is implicitly uppercased
à®ƒ[ì›ƒ]^^ == SET of Person     # Non-system type (person is not system)

à®ƒ[T]^ == Set[T]
à®ƒ[ì›ƒ^]^ == Set of Person

ì›ƒ^ = SET[ì›ƒ] = à®ƒ[ì›ƒ]^^  the SET of all persons
ì›ƒ_1 = a specific person, an Atom,  e.g. Alice
ì›ƒ_1 âˆˆ ì›ƒ^
ì›ƒ = ì›ƒ^1 = person 'query'   
ì›ƒ âŠ†  ì›ƒ^  
ì›ƒ  âˆˆ  â„˜(ì›ƒ^) 
ì›ƒ[1] = first result from person query, e.g. Alice
ì›ƒ[1] âˆˆ ì›ƒ
ì›ƒ^ X ì›ƒ^ =  Person X Person  =  à®ƒ[ì›ƒ]^^2   
ì›ƒ^ X ì›ƒ^ X ì›ƒ^ = à®ƒ[ì›ƒ]^^3


### The Foundations 3


s               symbol
s^              type S of s
s^ Â¬âˆˆ s^1      a bit weird I know but don't worry about it too much

Types
    ì›ƒ^ = Person
    ì›ƒ^ Â¬âˆˆ ì›ƒ^1
    ì›ƒ^ X ì›ƒ^ =  Person X Person  =  ì›ƒ^ X ì›ƒ^   
    ì›ƒ^ X ì›ƒ^ X ì›ƒ^ X .... = ì›ƒ^ XX n     # TODO maybe not needed, keep here for reference 

System types

    Set, List

    à®ƒ = set       natural language
    à®ƒ^ = Set      

    à®ƒ^[T] = Set[T]    T is a generic type
    à®ƒ^[S^] -> S^      reduction to prevent loops (S is a symbol)

    à®ƒ^[ì›ƒ^] -> ì›ƒ^     The Set of all persons


Atoms
    ì›ƒ_1 = a specific person, an Atom,  e.g. Alice
    ì›ƒ_1 âˆˆ ì›ƒ^

Queries

ì›ƒ = ì›ƒ^1 = person 'query'   
ì›ƒ âŠ†  ì›ƒ^  
ì›ƒ  âˆˆ  â„˜(ì›ƒ^)     # ì›ƒ is a finite subset of the Person universe
ì›ƒ[1] = first result from person query, e.g. Alice. Indexing starts from 1.
ì›ƒ[1] âˆˆ ì›ƒ


## Markdown experiments

"Markdown in markdown" could solve some problems
when in need avoid lists / preserve spaces / need to display clickable links 

```markdown

[foo](https://ciao.com)
bar
```


## Types

TODO just a draft, define better

-> = link
<- = backlink
<-> = bidirectional link


- all properties values are finite. 
- properties are _not_ links to other entities.

â˜‰.P = access property P. 
â˜‰.L = access link L. A link is a set of pointers to other entities.

Type declaration

```
ì›ƒ^ = á› ^:
  name : Str
  age  : Nat
  friends <-> ì›ƒ^
  home -> ğŸ ^ 
  TODO backlinks
```

ì›ƒ^ = á› : name : Str; age : Nat


ì›ƒ^ = â˜‰^:
  name : Str
  age  : Nat


```
ì›ƒ^ = â˜‰^[name : Str, age : Nat]
```

```
ì›ƒ^ = â˜‰^[
    name : Str
    age  : Nat
]
```




## References

- Tensor semantics / DisCoCat â€” categorical linguistics uses a similar compositional, Fock-space-like construction.

- Knowledge-graph embeddings â€” treat n-ary relations as tensors and learn numerical weights for them.